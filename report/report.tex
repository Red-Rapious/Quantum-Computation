\documentclass[12pt,a4paper]{article}
\usepackage[a4paper,margin=2cm]{geometry}

\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[kerning=true]{microtype}
\usepackage{lmodern}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}

\usepackage{mathtools}
\usepackage{wrapfig}
\usepackage{enumitem}
\usepackage[
    backend=biber,
    style=numeric
]{biblatex}

\usepackage{hyperref}

\addbibresource{report.bib}

\theoremstyle{plain}
\newtheorem*{theorem}{Theorem}
\newtheorem*{example}{Example}
\newtheorem*{remark}{Remark}
\theoremstyle{definition}
\newtheorem*{definition}{Definition}
\newtheorem*{thesis}{Thesis}

\DeclarePairedDelimiter\ket{\lvert}{\rangle}

\makeatletter

\title{\vspace{-5ex} \textbf{Quantum Computation}}
\author{Antoine Groudiev}
\date{\vspace{-1ex}\today}
\markright{Antoine Groudiev}{}
\pagestyle{myheadings}

\begin{document}
\maketitle
One of the most widely used system for secure data transmission is the RSA scheme; its security relies on the assumption that the integer factorization problem is hard. To this day, there is indeed no known efficient algorithm to factor an integer \textit{on a classical computer}.

Nevertheless, this problem can be solved in polynomial time on a quantum computer, using Shor's algorithm. A large enough quantum computer would therefore be able to break the RSA encryption scheme.

We will define the behavior of a quantum computer using two quantum computational models, and delve into quantum complexity theory, the study of complexity classes of problems solved using these quantum models. We will end by describing the Deutsch-Jozsa algorithm, to prove that a quantum computer can be exponentially faster than a deterministic classical computer.

\tableofcontents

\section{Introduction to Quantum Computers}
A classical computer uses the \emph{bit} as a basic unit, a system which can be in exactly one of the two states \texttt{0} and \texttt{1}. Similarly, a quantum computer uses a basic unit called \emph{qubit}, which can be in a \emph{superposition} of two states. A qubit can be described as a linear combinaison of both states, each coefficient being related to the probability that the qubit is in the given state. This way, a qubit can store more information than a simple bit, by storing information for both states at a time.

\subsection{Dirac notation}
While representing the state of a classical bit is quite simple, manipulating qubits requires more advanced notation. 
The state of a qubit is often represented using the Dirac notation, also known as the Bra-ket notation.\cite{dirac-notation}.

A qubit of state $\Psi$ is noted $\ket{\Psi}$, and is in a superposition of the two state $\ket{0}$ and $\ket{1}$. This superposition can be written as:
\begin{equation*}
    \ket{\Psi}=\alpha\ket{\Psi}+\beta\ket{\Psi}
\end{equation*}
where $\alpha, \beta\in \mathbb{C}$ are called the states amplitudes. 

\begin{example}[Schrödinger's cat]
    \begin{equation*}
        \ket{\textnormal{Schrödinger's cat}} = \alpha\ket{\textnormal{dead}} + \beta\ket{\textnormal{alive}}
    \end{equation*}
\end{example}

The probability to measure the qubit in the state $\ket{0}$ (and respectively $\ket{1}$) is $|\alpha|^2$ (respectively $|\beta|^2$). This interpretation gives us a normalization condition:
\begin{equation*}
    |\alpha|^2+|\beta|^2=1
\end{equation*}
since the qubit must be mesured in one on the two states.

\begin{example}[LFCC exam]
    Assume that you have a probability $p\in[0, 1]$ of passing the next LFCC exam. Your result at the exam can be represented using one qubit in the following state:
    \begin{equation*}
        \ket{\textnormal{exam}} = \sqrt{p} \: \ket{\textnormal{pass}}+\sqrt{1-p} \: \ket{\textnormal{fail}}
    \end{equation*}
    We can verify that the normalization condition is respected:
    \begin{equation*}
        (\sqrt{p})^2 + (\sqrt{1-p})^2 = 1
    \end{equation*}
\end{example}

\subsection{Vector representation}
Writing qubits is nice, but we would like to be able to change their state too. The Dirac notation is not the most practical one when the possible states ($\ket{0}$ and $\ket{1}$) are explicit. Instead, we can use a vector representation:
\begin{equation*}
    \ket{\Psi} = \begin{pmatrix}\alpha\\\beta\end{pmatrix}
\end{equation*}
This notation allows us to use linear algebra tools to express physical conditions and changes. The normalization condition simply becomes:
\begin{equation*}
    \|\ket{\Psi}\|_2 = 1
\end{equation*}
Furthermore, we can model an action that changes the qubit's state simply by a matrix $U$. If a qubit of initial state $\ket{\Psi}$ goes through some quantum gate (more on this later) represented by $U$, the final state $\ket{\Psi'}$ would be:
\begin{equation*}
    \ket{\Psi'} = U\ket{\Psi}
\end{equation*}

Obviously, we want $\ket{\Psi'}$ to respect the normalization condition for every qubit $\Psi$. This requires $U$ to be a unitary matrix, that is $UU^\dagger = I_2$, where $U^\dagger$ is the conjugate transpose of $U$\footnote{The conjugate transpose is usually noted $U^\star$, but I guess that quantum physicists prefer the medieval vibe of $\dagger$.}.

\subsection{The Bloch sphere}
%When dealing with simple amplitudes, like $\alpha, \beta\in [0, 1]$, the state of a qubit can be simply represented using a 1-dimensional line:
% TODO: insert picture

\begin{wrapfigure}[13]{r}{0.4\textwidth}
    \centering
    \includegraphics*{bloch-sphere}
    \caption{A Bloch sphere}
\end{wrapfigure}

Visualizing the state of a qubit - and the transformations of this state as physical transformations are applied to it - can be challenging. A common way to visualize a qubit is the Bloch sphere.

Since $\|\ket{\Psi}\|_2=1$, we can uniquely\footnote{Except when $\ket{\Psi}=\ket{0}$ or $\ket{\Psi}=\ket{1}$, since $\phi$ can take any value.} write $\ket{\Psi}$ as:
\begin{equation*}
    \ket{\Psi}=\cos(\theta/2)\:\ket{0} + e^{i\phi}\sin(\theta/2)\: \ket{1}
\end{equation*}
where $0\leq\theta\leq\pi$ and $0\leq\phi<2\pi$. This parametrization of $\ket{\Psi}$ corresponds to spherical coordinates, and uniquely define a vector $\vec{a}\in\mathbb{R}^3$:
\begin{equation*}
    \vec{a}=\begin{pmatrix}\sin\theta\cos\phi\\\sin\theta\sin\phi\\\cos\theta\end{pmatrix}
\end{equation*}

The mesure of the qubit $\ket{\Psi}$ can be seen as the projection of this vector on either $\ket{0}$ or $\ket{1}$, i.e. on $\vec{z}$ or $-\vec{z}$. The closer the point on the sphere is to a pole, the higher the probability to be mesured in this state. When the vector is pointing directly to the top, the probability to be mesured in $\ket{0}$ is $1$; when pointing directly down, the probability is $0$, and when the vector is orthogonal to $\vec{z}$, the probability is $\frac{1}{2}$.

\begin{figure}[!ht]
    \centering
    \includegraphics*[scale=0.4]{bloch-examples.png}
    \caption{Examples of vectors on the Bloch sphere for some simple states}
\end{figure}

\section{Quantum Computational Models}
To study the complexity of different problems with a quantum point of view, we need a model for a quantum computer. Much like classical computers, two approaches coexist: the representation of a quantum computer as a circuit, using quantum logic gates, and an abstract model called quantum Turing machine, by analogy with the classical Turing machine.

\subsection{Quantum Circuits}
A \emph{quantum circuit} is the counterpart of the classical circuit; from an abstract point of view, it is composed of a multiple qubits, a sequence of \emph{quantum gates}, and special gates called \emph{measurements}, the quantum phenomenon which projects the qubit in one pure state. Consider the circuit below as an example. Each line of the circuit represents one qubit, and the $x$-axis represents time.

\begin{figure}[!h]
    \centering
    \includegraphics*[scale=0.35]{deutsch-circuit-n.png}
    \caption{An example circuit (Deutsch-Jozsa's algorithm, which we will study later)}
\end{figure}

A quantum gate takes into input $n$ qubits, and modifies the probability of each qubit to be in each state. This can be seen visualy: the quantum gate changes the position of the qubit on the surface of the Bloch sphere. Therefore, quantum gates are often represented as unitary matrices of size $2^n \times 2^n$, i.e. elements of $U(2^n, \mathbb{C})$. We will now present a few basic quantum gates.

\subsubsection{The \texorpdfstring{$X$}{X} Gate}
The $X$ gate is the quantum equivalent of the classical $NOT$ gate. It takes one qubit as an input, and permutes its amplitudes. Formally:
\begin{equation*}
    X : \alpha\ket{0} + \beta\ket{1} \mapsto \beta\ket{0} + \alpha\ket{1}
\end{equation*}
The unitary matrix associated to $X$ is:
\begin{equation*}
    X \cong \begin{pmatrix}
        0&1\\
        1&0
    \end{pmatrix}
\end{equation*}

\subsubsection{The \texorpdfstring{$Z$}{Z} gate}
The $Z$ gate does not have a classical equivalent; its action over one qubit is simply to leave the $\ket{0}$ component untouched, and to multiply the $\ket{1}$ component by $-1$:
\begin{equation*}
    Z : \alpha\ket{0} + \beta\ket{1} \mapsto \alpha\ket{0} - \beta\ket{1}
\end{equation*}
Or, written in matrix form:
\begin{equation*}
    Z \cong \begin{pmatrix}
        1&0\\
        0&-1
    \end{pmatrix}
\end{equation*}

\subsubsection{Hadamard Gate}
The Hadamard gate is a one-qubit gate without classical equivalent; one of its most basic use is to generate superposition on a qubit. The unitary matrix associated to the Hadamard gate, written $H$, is the following:
\begin{equation*}
    H \cong \frac{1}{\sqrt{2}}
    \begin{pmatrix}
        1&1\\
        1&-1
    \end{pmatrix}
\end{equation*}
An immediate result is that:
\begin{equation*}
    \begin{cases}
        H\ket{0} = \frac{1}{\sqrt{2}}(\ket{0}+\ket{1}) \\
        H\ket{1} = \frac{1}{\sqrt{2}}(\ket{0}-\ket{1})
    \end{cases}
\end{equation*}
meaning that a qubit starting in a \emph{pure} state ($\ket{0}$ or $\ket{1}$) is transformed into a qubit in a balanced superposition of $\ket{0}$ and $\ket{1}$.

\begin{wrapfigure}[9]{l}{0.5\textwidth}
    \label{fig:basic-circuit}
    \centering
    \includegraphics*[scale=0.3]{basic-circuit.png}
    \caption{A basic circuit with the H gate}
\end{wrapfigure}

If we consider the circuit \ref{fig:basic-circuit} on the left, the probability to measure $\ket{0}$ is exactly $\frac{1}{2}$. (Note that this is possibly the only method to have true random numbers.) If we were to modify the circuit to add an $X$ gate between the Hadamard gate and the measuring "gate", the outputs probabilities would not change. 

Note that like every quantum gate represented by an unitary matrix, and unlike many classical gates, the Hadamard gate is reversible. This might seem counter-intuitive since the previous example suggests that we "lost" the information on the qubit. 

\begin{remark}
    Similarly to $XOR$, which can be constructed using only $AND$ and $OR$, the gates presented above are not "independent": it is possible\footnote{The proof is left as an exercise to the reader} to construct the $X$ gate using only $Z$ and $H$ gates.
\end{remark}

\subsubsection{Entanglement}
The set of gates above lack expressivity, since they operate on a single qubit only. A pure quantum phenomenon is \emph{entanglement}, meaning that multiple qubits are correlated.

\begin{example}[Bell's entanglement]
    Consider two untangled qubits $\Psi$ and $\Phi$. Their default state is:
    \begin{equation*}
        \ket{\Psi\Phi} = \frac{1}{\sqrt{4}} \left(\ket{00}+\ket{01}+\ket{10}+\ket{11}\right)
    \end{equation*}
    meaning that each outcome of the universe $\{(0,0); (1,1); (1,0); (1,1)\}$ is equally probable. By entangling $\Psi$ and $\Phi$, it is possible to put them in the \emph{Bell state}, that is: 
    \begin{equation*}
        \ket{\Psi\Phi} = \frac{1}{\sqrt{2}} \left(\ket{00}+\ket{11}\right)
    \end{equation*}
    Where the only possible outcomes are $(0, 0)$ and $(1, 1)$. By measuring $\Psi$, we can deduct the "value" of $\Phi$, exactly as if it was measured, which breaks the quantum superposition phenomenon.
\end{example}

\subsubsection{CNOT gate}
\begin{wrapfigure}{l}{0.5\textwidth}
    \centering
    \includegraphics*[scale=0.5]{cnot.png}
    \caption{Circuit representation of CNOT}
\end{wrapfigure}
The \emph{Controlled NOT} gate, (or CNOT gate) is a fundamental gate, which allows to entangle qubits. It acts on two qubits, a \emph{control qubit}, and a \emph{target qubit}. Intuitively, if the control qubit is $\ket{0}$, the target qubit is unchanged; if the control qubit is $\ket{1}$, we apply an $X$ gate to the target qubit. (Note that this description was expressed in the $(\ket{0}, \ket{1})$ basis, but that the control qubit is in general in a superposition of pure states.) 

This gate can be interpreted as the quantum equivalent of the classical "reversible XOR" gate, a $2\times 2$ gate taking in input $x$ and $y$, and returning $x$ and $x\oplus y$\footnote{$\oplus$ is used in quantum mechanics to denote the addition modulo 2, or similarly the XOR operation}.

The action of the CNOT gate corresponds to the following matrix:
\begin{equation*}
    CNOT \cong \begin{pmatrix}
        1&0&0&0\\
        0&1&0&0\\
        0&0&0&1\\
        0&0&1&0
    \end{pmatrix}
\end{equation*}
or, seen otherwise, the CNOT gate transforms
\begin{equation*}
    \alpha\ket{00}+\beta\ket{01}+\gamma\ket{10}+\delta\ket{11}
\end{equation*}
in
\begin{equation*}
    \alpha\ket{00}+\beta\ket{01}+\delta\ket{10}+\gamma\ket{11}.
\end{equation*}
We will see this gate in use when we'll study the Deutsch-Jozsa algorithm.

\subsection{Quantum Finite Automaton}
\subsubsection{Quantum Languages}
Let $\Sigma$ be an alphabet, and $L\subseteq \Sigma^\star$ a language over the alphabet $\Sigma$. Another way to see this language, apart from a subset of $\Sigma^\star$, is using its characteristic function $\chi_L$:
\begin{equation*}
    \chi_L(w) = \begin{cases*}
        1 & if $w\in L$\\
        0 & otherwise
    \end{cases*}
\end{equation*}

By analogy to this, we can define a \emph{quantum language} as a function mapping words to probabilities.\cite{quantum-automata-grammars}
\begin{definition}[Quantum language]
    A quantum language over the alphabet $\Sigma$ is a function $f$ such as:
    \begin{equation*}
        f : \Sigma^\star \to [0, 1]
    \end{equation*}
    $f$ is a classical alphabet if $f(\Sigma^\star) \subseteq \{0, 1\}$.
\end{definition}

\subsubsection{Definition of QFAs and QRLs}
\begin{definition}[QFA]
    A \emph{Quantum Finite Automaton} $Q=(H, s_{\textnormal{init}}, H_{\textnormal{accept}}, P_{\textnormal{accept}}, \Sigma, \delta)$ consists of:
    \begin{enumerate}[label=--, noitemsep]
        \item a Hilbert space\footnote{Recall that a Hilbert space is an inner product space complete for the distance induced by the inner product} $H$ of dimension $n$. (This will generalize the set $Q$ of states of a classical DFA.)
        \item an initial normalized vector $s_{\textnormal{init}}\in H$ (i.e. $\|s_{\textnormal{init}}\|^2=1$). (This is the equivalent of the initial state in a DFA.)
        \item a subspace $H_{\textnormal{accept}} \subseteq H$, and an operator $P_{\textnormal{accept}}$ which projects onto it
        \item an alphabet $\Sigma$
        \item a function $\delta : \Sigma \to U_n(\mathbb{C})$\footnote{$U_n(\mathbb{C})$ is the set of unitary matrices of size $n$}, mapping each letter of $a\in\Sigma$ to an unitary matrix $U_a\in\Sigma$.
    \end{enumerate}
    
    We will also write $\delta^\star(w=w_1\cdots w_{|w|}) = \delta(w_{|w|})\cdots \delta(w_1) = U_{w_{|w|}}\cdots U_{w_1}$. Finally, the language recognized by $Q$ is the following function:
    \begin{equation*}
        f_Q : w \mapsto \|P_{\textnormal{accept}}\delta^\star(w)s_{\textnormal{init}}\|^2
    \end{equation*}
    (It is convenient to see the vector and matrix multiplications being computed from right to left as the word is being read by the automata.)
\end{definition}

Intuitively, we start from the $s_{\textnormal{init}}$ vector (or state), and we follow $w$ by multiplying the current vector by the matrix associated to the current letter of the input word. When the word is finished, we project the current vector (which remains of norm $1$) on the space $H_{\textnormal{accept}}$ using the operator $P_{\textnormal{accept}}$. If $\delta^\star(w)s_{\textnormal{init}}\in H_{\textnormal{accept}}$, the $P_{\textnormal{accept}}$ will left $\delta^\star(w)s_{\textnormal{init}}$ untouched, and the output probability will be $1$; otherwise, the output probability decreases as the norm projection of $\delta^\star(w)s_{\textnormal{init}}$ decreases.

The end of the process corresponds to a measurement, and $f_Q(w)$ can be interpreted as the probability that this measurement has an acceptable outcome. 

\begin{definition}[QRL]
    A \emph{Quantum Regular Language} is a quantum language recognized by a QFA.
\end{definition}

\subsubsection{A few properties of QRLs}
\begin{theorem}[Quantum Pumping Lemma]
    If $f$ is a QRL, then for any word $w\in\Sigma^\star$ and any $\varepsilon > 0$, there is a $k\in \mathbb{N}^\star$ such that $\|f(uw^kv) - f(uv)\| < \varepsilon$ for any words $u, v$. Moreover, if $f$'s automaton is $n$-dimensional, there is a constant $c$ independent of $\varepsilon$ such that $k < (c\varepsilon)^{-n}$.
\end{theorem}
%This version of the pumping lemma is stronger than the classical property of regular languages. Note that if we choose $f$ to be a classical language (i.e. $f(\Sigma^\star)\subseteq \{0, 1\}$), by choosing $\varepsilon=\frac{1}{2}$, 

\subsection{Quantum context-free languages}
\begin{definition}[Quantum Grammar\footnote{\url{https://xkcd.com/1090/}}]
    A \emph{Quantum Grammar} $G=(V, T, I, P)$ of \emph{dimensionality} $n$ consists of:
    \begin{itemize}[label=--, noitemsep]
        \item an alphabet $V$ of variables
        \item an alphabet $T$ of terminals
        \item an initial variable $I\in V$
        \item a finite set of productions $P$. 
    \end{itemize}
    A \emph{production} of $P$ is of the form $\alpha\to \beta$, where $(\alpha, \beta)\in V^\star\times (T\cup V)^\star$. To each production i $P$ is associated a set of complex amplitudes $\left(c_k(\alpha\to\beta)\right)_{1\leq k\leq n}$.

    Consider one derivation $\alpha\Rightarrow\beta$, a chain of strings in which at each step one substring is replaced with another according to a production rule. We define the $k$-th amplitude $c_k$ of \emph{one} derivation to be the product of the $k$-th amplitudes of the derivations used in the chain. Furthermore, we define $c_k(\alpha\Rightarrow\beta)$ to be the sum of the $c_k$ for \emph{all the derivation} from $\alpha$ to $\beta$.

    The $k$-th amplitude of a word $w\in T^\star$ is defined as $c_k(w) = c_k(I\Rightarrow w)$. Finally, $G$ \emph{generates} the quantum language $f$ defined as:
    \begin{equation*}
        f(w) = \sum_{k=1}^n \|c_k(w)\|^2
    \end{equation*}
\end{definition}

\begin{remark}
    This construction appear to be much more complicated than the standard grammar construction. This is mainly because of the introduction of the $n$ different amplitudes $(c_k)$. Why do we need multiple amplitudes instead of just one? The reason is pretty technical, but multiple amplitudes are needed to prevent multiple paths from interfering.
\end{remark}

\begin{definition}[QCFG]
    A quantum grammar $G$ is \emph{context-free} if the only productions with non-zero amplitudes are the productions $\alpha\to\beta$ with $\alpha\in V$.
\end{definition}

\begin{definition}[QCFL]
    A \emph{Quantum Context-Free Language} is a language generated by a quantum context-free grammar.
\end{definition}

As you could have guessed, an important result on QCFL is that a quantum language is context-free if and only if it is recognized by the quantum equivalent of a push-down automata.

\begin{definition}[QPDA]
    A \emph{Quantum Push-Down Automata} $Q=(H=Q\otimes \Sigma, T, Q_{\textnormal{acccept}}, s_{\textnormal{init}}, A, \delta)$ consists of:
    \begin{itemize}[label=--, noitemsep]
        \item a Hilbert space $H$ (the space of configurations of the automata). More specifically, we must have $H=Q\otimes \Sigma$ for some spaces $Q$, $\Sigma$\footnote{$Q\otimes \Sigma$ denotes the tensor product of spaces $Q$ and $\Sigma$}
        \item $Q$ is a finite-dimensional space called the \emph{control state}
        \item $\Sigma$ is an inifinite-dimensional space called the \emph{stack space}
        \item each basis vector of $\Sigma$ is a finite word over the stack alphabet $T$
        \item an initial state $s_{\textnormal{init}}$, which must be a superposition of a finite number of initial control states and stack states
        \item a subspace $Q_{\textnormal{acccept}} \subseteq Q$, such as the accepting space $H_{\textnormal{acccept}}=Q_{\textnormal{acccept}}\otimes \{\varepsilon\}$ (this requires that the stack is empty at the end of the word for it to be accepted by the automata)
        \item an operator $P_{\textnormal{acccept}}$ projecting on $Q_{\textnormal{acccept}}\otimes \{\varepsilon\}$
        \item an input alphabet $A$
        \item a transition function $\delta$, such as $\forall a\in A$, $\delta(a)$ is a unitary endomorphism of $H$
    \end{itemize}

    To ensure that the stack has indeed a LIFO\footnote{Last In, First Out} behavior, we add some constraints on the transitions probabilities. Let $q_1, q_2\in Q$ be control states, and $\sigma_1, \sigma_2\in T$ be stack states; then the transition amplitude from $(q_1, \sigma_1)$ to $(q_2, \sigma_2)$ can only be non-zero if there is $t\in T$ such as:
    \begin{equation*}
        (\sigma_1t = \sigma_2) \lor (\sigma_1 = \sigma_2t) \lor (\sigma_1 = \sigma_2)
    \end{equation*}
    meaning that the transition can only push, pop, or leave the stack unchanged. Furthermore, transition amplitudes can only depend on the top (rightmost) symbol of $\sigma_1$ and $\sigma_2$.
\end{definition}

\begin{remark}
    Conversely to a classical PDA, transitions can depend on both the top symbol of the stack, and the symbol below it. This is because we allowed the dependency on both $\sigma_1$ and $\sigma_2$. This is necessary for the endomorphisms to be unitary. 
\end{remark}

\begin{theorem}
    A quantum language is a QCFL if and only if it is recognized by a QPDA.
\end{theorem}

%\begin{proof}
%    This is merely an outline of the full proof\cite{quantum-automata-grammars}.
%\end{proof}

\subsection{Quantum Turing Machine}
Similarly to the classical case, the previous constructions can be generalized to gain expressivity. This leads to the following definition of a Quantum Turing Machine\cite{qtm-circuits}\cite{qc-theory-bernstein}, the equivalent of a classical Turing machine, but using the previous constructions using Hilbert spaces and transition matrices:

\begin{definition}[QTM] A \emph{Quantum Turing Machine} (or QTM) $M = (H, \Gamma, b, \Sigma, \delta, q_0, F)$ consists of:
\begin{enumerate}[label=--, noitemsep]
    \item a Hilbert space $H$ (replacing the classical set of states $Q$)
    \item another Hilbert space $\Gamma$ (replacing the classical set of tape symbols)
    \item a blank symbol $b\in \Gamma$
    \item an alphabet of input and output symbols $\Sigma$
\end{enumerate}
    
(Note: the previous definition of a QTM restricts the head movements to $\{L, R\}$, but a generalized version $\{L, N, R\}$ can similarly be introduced. While this does not matter in term of expressivity for a classical TM, there is a difference for QTMs.)

\end{definition}

\section{Quantum Complexity Theory}
Similarly to the study of classical algorithms, we can regroup quantum problems in classes depending on their solvability by a quantum computational model under time and space constraints. 

\subsection{Quantum complexity classes}
\subsubsection{The BQP class}
An important class of problem is the BQP class; it is the equivalent of the BPP class (Bounded-error, Probabilistic Polynomial time) for classical probabilistic computers.

\begin{definition}[BQP] 
    The \emph{Bounded-error Quantum Polynomial time} (BQP) class is the set of decision problems which can be solved in polynomial time by a quantum Turing machine, with an error of at most $\frac{1}{3}$. 
\end{definition}
The formal definition often involves a maximum error of $\frac{1}{3}$ in one run, but any bound strictly lower than $\frac{1}{2}$ is sufficient, since multiple runs of the algorithm can be chained to reduce the error.

\begin{definition}[Promise-BQP]
    The \emph{Promise-BQP} class is the generalization of the BQP class, in which the input is \emph{promised} to belong to a specific subset of all inputs.
\end{definition}

We have BQP $\subset$ Promise-BQP. We are going to present a Promise-BQP-complete problem; it is interesting to notice that no BQP-complete problem is known.

\subsubsection{A Promise-BQP-complete problem}
\begin{definition}[APPROX-QCIRCUIT-PROB problem\footnote{I know, the name is slightly more complicated than "NP"}]
    Having as an input two numbers $\alpha, \beta$ such as $0\leq\beta<\alpha\leq 1$, and the description of a quantum circuit $C$ such as:
    \begin{itemize}[label=--, noitemsep]
        \item the circuit acts on $n$ qubits
        \item the circuit contains $m$ gates
        \item the number of gates $m$ is polynomial in $n$
        \item the probability $P$ to measure the first output qubit of the circuit initialized at $\ket{0}^{\otimes n}$ is either $P\geq\alpha$ or $P\leq\beta$ (this is the promise)\footnote{The notation $\ket{0}^{\otimes n}$ means that the $n$ input qubits are initialized to $\ket{0}$}
    \end{itemize}
    the algorithm needs to output whether $P\geq\alpha$ or $P\leq\beta$.
\end{definition}

\begin{theorem}
    Any BQP problem reduces to APPROX-QCIRCUIT-PROB.
\end{theorem}

\begin{proof}
    
\end{proof}

\subsubsection{Relationship to classical complexity classes}


\subsection{Relationship to the Church-Turing Thesis}
\begin{thesis}[Church-Turing Thesis]
    A function on the natural numbers can be calculated by an effective method if and only if it is computable by a Turing machine.
\end{thesis}

Any quantum algorithm can be simulated either by hand, or on a classical computer, even if the resulting complexity of the computation is changed. Formally, it can be shown that a quantum Turing machine can be simulated on a Universal Turing Machine. Therefore, the existence of quantum computers do not disprove the Church-Turing thesis.

Nevertheless, the Church-Turing thesis do not state anything about the time complexity of the simulation. Historically, this lead to the following extension of the Church-Turing Thesis:
\begin{thesis}[Extended Church-Turing Thesis]
    A probabilistic Turing machine can efficiently simulate any realistic model of computation.
\end{thesis}

Showing that $BPP \varsubsetneq BQP$ would imply that quantum computers are in certain cases more efficient than classical computers. This would therefore invalidate the extended Church–Turing thesis. A quantum-extended version of the thesis has therefore been proposed\cite{quantum-applied}:
\begin{thesis}[Quantum-extended Church-Turing Thesis]
    Any realistic physical computing device can be efficiently simulated by a fault-tolerant quantum computer.
\end{thesis}

Overall, what these variations of the original Church-Turing thesis show, is that the existence of quantum computers do not change our fundamental understanding of what computation is. Quantum computers are only capable of solving problems we can already solve classically. Nevertheless, a sufficiently large quantum computer could \emph{efficiently} solve problems that are to this day considered as "hard" in practice. 

\section{The Deutsch-Jozsa Algorithm}
The Deutsch-Jozsa algorithm\cite{deutsch-jozsa} is an important quantum algorithm, not because of any practical use, but because it shows the interest of a quantum computer over a classical computer. The existence of the problem and algorithm proves that there is an \emph{oracle separation} between the EQP and P class: this is a black box problem that can be solved in polynomial time using a quantum computer, but that cannot be solved by a classical computer in polynomial time.

\subsection{Problem description}
Let's consider a function $f$ operating on $n$ bits or qubits. That is:
\begin{equation*}
    f : \{ 0, 1 \}^n \to \{ 0, 1 \}
\end{equation*}
This function is assumed to have a specific property: it is either \emph{constant} or \emph{balanced}:
\begin{equation*}
    |f^{-1}(\{0\})| = n \lor |f^{-1}(\{1\})| = n \lor \left(|f^{-1}(\{0\})| = |f^{-1}(\{1\})| = \frac{n}{2}\right)
\end{equation*}
This means that either the function produces only \texttt{0}, or it produces only \texttt{1}, or it produces exactly half of \texttt{0} and half of \texttt{1}. This is the promise of the problem.

The $f$ function behaves like a black box, or an \emph{oracle}: it is able to output the outcome of $f(x)$ is an single operation for any $x$. The algorithm is asked to determine whether the function is constant or balanced.

\subsection{Classical solution}
A deterministic computer needs in the worst case to mesure more than half the $2^n$ possible outcomes for $f$, i.e. $2^{n-1}+1$; the best time complexity is therefore exponential. Nevertheless, this problem can be solved efficiently on a probabilistic computer with a high probability.

\subsection{Quantum algorithm}
We will describe the algorithm in the case $n=1$, simply known as Deutsch's algorithm. Interestingly, the same procedure simply extends to any value of $n$. 

The implementation of the function $f$ is assumed to be of the form:
\begin{equation*}
    f : \ket{x}\ket{y} \mapsto \ket{x}\ket{f(x)\oplus y}
\end{equation*}
This is needed to ensure that the gate is unitary.

The algorithm uses two qubits. Its circuit representation is the following:
\begin{figure}[!h]
    \centering
    \includegraphics*[scale=0.4]{deutsch-circuit.png}
    \caption{The quantum circuit used by Deutsch's algorithm}
\end{figure}

Note that we will only measure the first qubit.\footnote{The second qubit is known as an \emph{ancilla qubit}: \url{https://en.wikipedia.org/wiki/Ancilla_bit}} The goal of this circuit is to obtain the value of $f(0)\oplus f(1)$. If the function is constant, $f(0)\oplus f(1) = 0$, and if the function is balanced, $f(0)\oplus f(1) = 1$. By knowing the value of $f(0)\oplus f(1)$, we can determine using the promise whether $f$ is constant or balanced. We will now describe the algorithm step-by-step.

\begin{enumerate}
    \item Initialize two qubits in the states such as the \emph{product state} of the qubits is $\ket{0}\ket{1}$.
    \item Apply to each qubit a Hadamard transform (fancy name for applying a Hadamard gate). The state changes to:
    \begin{equation*}
        \left(\frac{\ket{0}+\ket{1}}{\sqrt{2}}\right) \left(\frac{\ket{0}-\ket{1}}{\sqrt{2}}\right)
    \end{equation*}
    \item Apply the $f$ gate to the qubits. According to the definition of the gate, the state changes to:
    \begin{align*}
        \frac{1}{2}\big[\ket{0}\big(\ket{0\oplus f(0)} - \ket{1\oplus f(1)}\big) + \ket{1}\big(\ket{0\oplus f(1)} - \ket{1\oplus f(1)}\big) \big] \\
        = \frac{1}{2}\big[(-1)^{f(0)}\ket{0}\big(\ket{0} - \ket{1}\big) + (-1)^{f(1)}\ket{1}\big(\ket{0} - \ket{1}\big) \big] \\
        = (-1)^{f(0)}\frac{1}{2}\big( \ket{0} + (-1)^{f(0)\oplus f(1)} \ket{1}\big)\big( \ket{0}-\ket{1}\big)
    \end{align*}
    This last form is interesting since we wrote the product state as an actual product of the two qubits states. If we look only at the state of the first qubit, we have after normalization:
    \begin{equation*}
        \frac{1}{\sqrt{2}}\big(\ket{0} + (-1)^{f(0)\oplus f(1)}\ket{1}\big)
    \end{equation*}
    \item Apply one final Hadamard gate to the first qubit. We obtain:
    \begin{equation*}
        \frac{1}{2} \big[ \big(1+(-1)^{f(0)\oplus f(1)}\big)\ket{0} + \big(1-(-1)^{f(0)\oplus f(1)}\big)\ket{1} \big]
    \end{equation*}
    \item Measure the qubit. Note that if $f(0)\oplus f(1) = 0$, the qubit is in state $\ket{0}$, and if $f(0)\oplus f(1) = 1$, the qubit is in state $\ket{1}$. Therefore, if we measure $\ket{0}$, the probability that $f$ is constant is $1$, and if we measure $\ket{1}$, the probability that $f$ is balanced is $1$. We solved the problem.
\end{enumerate}

\subsection{General case}
The ideas for the general case of the Deutsch-Jozsa algorithm are the exact same as the ones in the Deutsch algorithm. The main change is to replace the first qubit by a bus of $n$ qubits:

\begin{figure}[!h]
    \centering
    \includegraphics*[scale=0.4]{deutsch-circuit-n.png}
    \caption{The quantum circuit used by Deutsch-Jozsa's algorithm in the general case}
\end{figure}

You can show, using calculations similar to what we did before, that the final probability to measure $\ket{0}^{\otimes n}$ is:
\begin{equation*}
    \|\frac{1}{2^n}\sum_{x=0}^{2^n-1}(-1)^{f(x)}\|^2
\end{equation*}
which is $1$ if and only if $f$ is constant.
Therefore, by measuring the $n$ first qubits at the end, you can say answer the problem by simply browsing in linear time the result of the measures; if a non-zero state is measured, $f$ is balanced (according to the promise), otherwise $f$ is constant.


\subsection{Complexity theory consequences}
We saw that this problem could not be solved exactly by a classical computer in polynomial time, meaning that the problem is not in P. Nevertheless, the problem is exactly solvable by a quantum computer in polynomial time, hence it is a problem of the class EQP (Exact Quantum Polynomial time). Therefore, the problem yields an oracle relative to which $EQP \neq P$.

This shows that some problems, the most famous one being the prime factoring problem, are exponentially slower\footnote{In the case of prime factoring, this is only true if P $\neq$ NP} on a classical computer than on a quantum computer.

\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}

\nocite{*}
\printbibliography

\end{document}